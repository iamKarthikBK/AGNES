//
// Generated by Bluespec Compiler, version 2021.07-3-g8227dc97 (build 8227dc97)
//
// On Fri Sep  3 12:08:29 PDT 2021
//
//
// Ports:
// Name                         I/O  size props
// RDY_ma_core_req                O     1 reg
// mv_core_resp                   O    33 reg
// RDY_mv_core_resp               O     1 const
// mav_fwd_req                    O    48 reg
// RDY_mav_fwd_req                O     1 reg
// RDY_ma_counter_interrupts      O     1 const
// RDY_ma_clint_msip              O     1 const
// RDY_ma_clint_mtip              O     1 const
// RDY_ma_set_meip                O     1 const
// mv_csr_mstatus                 O    32
// RDY_mv_csr_mstatus             O     1 const
// mv_csrs_to_decode              O   101
// RDY_mv_csrs_to_decode          O     1 const
// mav_upd_on_ret                 O    32
// RDY_mav_upd_on_ret             O     1 const
// mav_upd_on_trap                O    32
// RDY_mav_upd_on_trap            O     1 const
// mv_mpp                         O     2 reg
// mv_resume_wfi                  O     1
// RDY_mv_resume_wfi              O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// ma_core_req_req                I    48
// ma_csr_misa_m                  I    32
// ma_frm_frm_val                 I     3
// ma_counter_interrupts_i        I    29
// ma_clint_msip_intrpt           I     1 reg
// ma_clint_mtip_intrpt           I     1 reg
// ma_set_meip_ex_i               I     1 reg
// ma_upd_privilege_prv           I     2
// mav_upd_on_trap_c              I     6
// mav_upd_on_trap_pc             I    32
// mav_upd_on_trap_tval           I    32
// mav_upd_on_trap_prv            I     2 unused
// EN_ma_core_req                 I     1
// EN_ma_counter_interrupts       I     1
// EN_ma_clint_msip               I     1
// EN_ma_clint_mtip               I     1
// EN_ma_set_meip                 I     1
// EN_mav_fwd_req                 I     1
// EN_mav_upd_on_ret              I     1
// EN_mav_upd_on_trap             I     1
//
// Combinational paths from inputs to outputs:
//   (ma_csr_misa_m,
//    ma_frm_frm_val,
//    ma_counter_interrupts_i,
//    ma_upd_privilege_prv,
//    EN_ma_counter_interrupts) -> mv_csrs_to_decode
//   ma_csr_misa_m -> mav_upd_on_ret
//   (ma_counter_interrupts_i, EN_ma_counter_interrupts) -> mv_resume_wfi
//   mav_upd_on_trap_c -> mav_upd_on_trap
//
//
// module : implementing read and write methods for group - 1 csrs and related side band 	         access
//
// Comments on the inlined module `wr_prv':
//   wire : stores the information on curent privilege level,		                updated by ma_upd_privilege, read in mv_csrs_to_decode, 		                ma_set_external_interrupt
//
// Comments on the inlined module `wr_frm':
//   wire : to hold the current frm value from the group-2,  		                 used in method mv_csrs_to_decode
//
// Comments on the inlined module `wr_csr_misa':
//   wire : to hold the current misa value from the other group MISA-s,u,n,c utilised
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mk_csr_grp1(CLK,
		   RST_N,

		   ma_core_req_req,
		   EN_ma_core_req,
		   RDY_ma_core_req,

		   mv_core_resp,
		   RDY_mv_core_resp,

		   EN_mav_fwd_req,
		   mav_fwd_req,
		   RDY_mav_fwd_req,

		   ma_csr_misa_m,

		   ma_frm_frm_val,

		   ma_counter_interrupts_i,
		   EN_ma_counter_interrupts,
		   RDY_ma_counter_interrupts,

		   ma_clint_msip_intrpt,
		   EN_ma_clint_msip,
		   RDY_ma_clint_msip,

		   ma_clint_mtip_intrpt,
		   EN_ma_clint_mtip,
		   RDY_ma_clint_mtip,

		   ma_set_meip_ex_i,
		   EN_ma_set_meip,
		   RDY_ma_set_meip,

		   mv_csr_mstatus,
		   RDY_mv_csr_mstatus,

		   mv_csrs_to_decode,
		   RDY_mv_csrs_to_decode,

		   ma_upd_privilege_prv,

		   EN_mav_upd_on_ret,
		   mav_upd_on_ret,
		   RDY_mav_upd_on_ret,

		   mav_upd_on_trap_c,
		   mav_upd_on_trap_pc,
		   mav_upd_on_trap_tval,
		   mav_upd_on_trap_prv,
		   EN_mav_upd_on_trap,
		   mav_upd_on_trap,
		   RDY_mav_upd_on_trap,

		   mv_mpp,

		   mv_resume_wfi,
		   RDY_mv_resume_wfi);
  input  CLK;
  input  RST_N;

  // action method ma_core_req
  input  [47 : 0] ma_core_req_req;
  input  EN_ma_core_req;
  output RDY_ma_core_req;

  // value method mv_core_resp
  output [32 : 0] mv_core_resp;
  output RDY_mv_core_resp;

  // actionvalue method mav_fwd_req
  input  EN_mav_fwd_req;
  output [47 : 0] mav_fwd_req;
  output RDY_mav_fwd_req;

  // action method ma_csr_misa
  input  [31 : 0] ma_csr_misa_m;

  // action method ma_frm
  input  [2 : 0] ma_frm_frm_val;

  // action method ma_counter_interrupts
  input  [28 : 0] ma_counter_interrupts_i;
  input  EN_ma_counter_interrupts;
  output RDY_ma_counter_interrupts;

  // action method ma_clint_msip
  input  ma_clint_msip_intrpt;
  input  EN_ma_clint_msip;
  output RDY_ma_clint_msip;

  // action method ma_clint_mtip
  input  ma_clint_mtip_intrpt;
  input  EN_ma_clint_mtip;
  output RDY_ma_clint_mtip;

  // action method ma_set_meip
  input  ma_set_meip_ex_i;
  input  EN_ma_set_meip;
  output RDY_ma_set_meip;

  // value method mv_csr_mstatus
  output [31 : 0] mv_csr_mstatus;
  output RDY_mv_csr_mstatus;

  // value method mv_csrs_to_decode
  output [100 : 0] mv_csrs_to_decode;
  output RDY_mv_csrs_to_decode;

  // action method ma_upd_privilege
  input  [1 : 0] ma_upd_privilege_prv;

  // actionvalue method mav_upd_on_ret
  input  EN_mav_upd_on_ret;
  output [31 : 0] mav_upd_on_ret;
  output RDY_mav_upd_on_ret;

  // actionvalue method mav_upd_on_trap
  input  [5 : 0] mav_upd_on_trap_c;
  input  [31 : 0] mav_upd_on_trap_pc;
  input  [31 : 0] mav_upd_on_trap_tval;
  input  [1 : 0] mav_upd_on_trap_prv;
  input  EN_mav_upd_on_trap;
  output [31 : 0] mav_upd_on_trap;
  output RDY_mav_upd_on_trap;

  // value method mv_mpp
  output [1 : 0] mv_mpp;

  // value method mv_resume_wfi
  output mv_resume_wfi;
  output RDY_mv_resume_wfi;

  // signals for module outputs
  wire [100 : 0] mv_csrs_to_decode;
  wire [47 : 0] mav_fwd_req;
  wire [32 : 0] mv_core_resp;
  wire [31 : 0] mav_upd_on_ret, mav_upd_on_trap, mv_csr_mstatus;
  wire [1 : 0] mv_mpp;
  wire RDY_ma_clint_msip,
       RDY_ma_clint_mtip,
       RDY_ma_core_req,
       RDY_ma_counter_interrupts,
       RDY_ma_set_meip,
       RDY_mav_fwd_req,
       RDY_mav_upd_on_ret,
       RDY_mav_upd_on_trap,
       RDY_mv_core_resp,
       RDY_mv_csr_mstatus,
       RDY_mv_csrs_to_decode,
       RDY_mv_resume_wfi,
       mv_resume_wfi;

  // inlined wires
  reg [32 : 0] rg_resp_to_core_1_wget;
  wire [65 : 0] csr_op_arg_wget;

  // register rg_fs
  // reg : Floating Status, describes the status of floating point unit
  reg [1 : 0] rg_fs;
  wire [1 : 0] rg_fs_D_IN;
  wire rg_fs_EN;

  // register rg_mcause
  // reg : Machine Cause, holds the exception code for identifying last exception
  reg [4 : 0] rg_mcause;
  wire [4 : 0] rg_mcause_D_IN;
  wire rg_mcause_EN;

  // register rg_mcounterie
  reg rg_mcounterie;
  wire rg_mcounterie_D_IN, rg_mcounterie_EN;

  // register rg_meie
  // reg : Machine External Interrupt Enable register
  reg rg_meie;
  wire rg_meie_D_IN, rg_meie_EN;

  // register rg_meip
  // reg : Machine External Interrupt Pending register
  reg rg_meip;
  wire rg_meip_D_IN, rg_meip_EN;

  // register rg_mepc
  // reg : Machine Exception Program Counter,can be used in holding the address of the 	  				 instruction interrupted upon Trap
  reg [30 : 0] rg_mepc;
  wire [30 : 0] rg_mepc_D_IN;
  wire rg_mepc_EN;

  // register rg_mie
  // reg : Machine Interrupt Enable
  reg rg_mie;
  reg rg_mie_D_IN;
  wire rg_mie_EN;

  // register rg_minterrupt
  // reg : is set whenever the trap is caused by an interrupt, part of MCAUSE register
  reg rg_minterrupt;
  wire rg_minterrupt_D_IN, rg_minterrupt_EN;

  // register rg_mode
  // reg : Mode register encodes the trap-handling-pc-address whether Direct/Vectored
  reg [1 : 0] rg_mode;
  wire [1 : 0] rg_mode_D_IN;
  wire rg_mode_EN;

  // register rg_mpie
  // reg : Machine Previous Interrupt-Enable, holds previous interrupt-enable bit active     				 prior to the TRAP
  reg rg_mpie;
  reg rg_mpie_D_IN;
  wire rg_mpie_EN;

  // register rg_mpp
  // reg : Machine Previous Privilege, holds previous privilege mode prior to the TRAP
  reg [1 : 0] rg_mpp;
  reg [1 : 0] rg_mpp_D_IN;
  wire rg_mpp_EN;

  // register rg_mprv
  // reg : mprv modifie s the privilege level at which loads and stores execute,
  reg rg_mprv;
  wire rg_mprv_D_IN, rg_mprv_EN;

  // register rg_msie
  // reg : Machine Software Interrupt Enable register
  reg rg_msie;
  wire rg_msie_D_IN, rg_msie_EN;

  // register rg_msip
  // reg : Machine Software Interrupt Pending register
  reg rg_msip;
  wire rg_msip_D_IN, rg_msip_EN;

  // register rg_mtie
  // reg : Machine Timer Interrupt Enable register
  reg rg_mtie;
  wire rg_mtie_D_IN, rg_mtie_EN;

  // register rg_mtip
  // reg : Machine Timer Interrupt Pending register
  reg rg_mtip;
  wire rg_mtip_D_IN, rg_mtip_EN;

  // register rg_mtval
  // reg : Machine Trap VALue, may be written by faulting virtual address/first XLEN/ILEN 	  				 bitsof faulting instruction
  reg [31 : 0] rg_mtval;
  wire [31 : 0] rg_mtval_D_IN;
  wire rg_mtval_EN;

  // register rg_mtvec
  // reg : Machine Trap VECtor, holds the Base address for changing pc
  reg [29 : 0] rg_mtvec;
  wire [29 : 0] rg_mtvec_D_IN;
  wire rg_mtvec_EN;

  // register rg_resp_to_core
  // reg : register to hold the response of this group for a csr operation request
  reg [32 : 0] rg_resp_to_core;
  wire [32 : 0] rg_resp_to_core_D_IN;
  wire rg_resp_to_core_EN;

  // ports of submodule ff_fwd_request
  wire [47 : 0] ff_fwd_request_D_IN, ff_fwd_request_D_OUT;
  wire ff_fwd_request_CLR,
       ff_fwd_request_DEQ,
       ff_fwd_request_EMPTY_N,
       ff_fwd_request_ENQ,
       ff_fwd_request_FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_rg_resp_to_core__dreg_update,
       CAN_FIRE_ma_clint_msip,
       CAN_FIRE_ma_clint_mtip,
       CAN_FIRE_ma_core_req,
       CAN_FIRE_ma_counter_interrupts,
       CAN_FIRE_ma_csr_misa,
       CAN_FIRE_ma_frm,
       CAN_FIRE_ma_set_meip,
       CAN_FIRE_ma_upd_privilege,
       CAN_FIRE_mav_fwd_req,
       CAN_FIRE_mav_upd_on_ret,
       CAN_FIRE_mav_upd_on_trap,
       WILL_FIRE_RL_rg_resp_to_core__dreg_update,
       WILL_FIRE_ma_clint_msip,
       WILL_FIRE_ma_clint_mtip,
       WILL_FIRE_ma_core_req,
       WILL_FIRE_ma_counter_interrupts,
       WILL_FIRE_ma_csr_misa,
       WILL_FIRE_ma_frm,
       WILL_FIRE_ma_set_meip,
       WILL_FIRE_ma_upd_privilege,
       WILL_FIRE_mav_fwd_req,
       WILL_FIRE_mav_upd_on_ret,
       WILL_FIRE_mav_upd_on_trap;

  // inputs to muxes for submodule ports
  wire MUX_rg_mcause_write_1__SEL_1,
       MUX_rg_mepc_write_1__SEL_1,
       MUX_rg_mie_write_1__SEL_1,
       MUX_rg_mpp_write_1__SEL_1,
       MUX_rg_mtval_write_1__SEL_1;

  // remaining internal signals
  reg [31 : 0] IF_ma_core_req_req_BITS_47_TO_36_EQ_0x300_THEN_ETC___d109,
	       x_wget__h649;
  wire [31 : 0] lv_mi_mask__h1454,
		readdata__h1564,
		readdata__h1574,
		rg_csr_mie__read__h1760,
		rg_csr_mip__read__h1963,
		x__h3100,
		x__h5393,
		x_data__h1653,
		x_data__h2059,
		x_data__h2080,
		x_data__h2100,
		x_wget_fst__h2296,
		x_wget_snd_fst__h2381;
  wire [30 : 0] r1__read__h1762, r1__read__h1965, result__h5993;
  wire [29 : 0] IF_rg_mode_5_EQ_1_87_AND_mav_upd_on_trap_c_BIT_ETC___d191,
		r1__read__h1764,
		r1__read__h1967;
  wire [28 : 0] _0_CONCAT_NOT_IF_wr_counter_interrupts_whas__9__ETC___d201,
		r1__read__h1766,
		r1__read__h1969,
		x__h2004;
  wire [27 : 0] r1__read__h1768, r1__read__h1971;
  wire [26 : 0] r1__read__h1770, r1__read__h1973;
  wire [25 : 0] r1__read__h1772, r1__read__h1975;
  wire [24 : 0] r1__read__h1774, r1__read__h1977;
  wire [23 : 0] r1__read__h1776, r1__read__h1979;
  wire [22 : 0] r1__read__h1778, r1__read__h1981;
  wire [21 : 0] r1__read__h1780, r1__read__h1983;
  wire [20 : 0] r1__read__h1782, r1__read__h1985;
  wire [19 : 0] r1__read__h1784, r1__read__h1987;
  wire [15 : 0] r1__read__h1786, r1__read__h1989;
  wire [1 : 0] x_wget_snd_snd__h2382;
  wire ma_core_req_req_BITS_47_TO_36_EQ_0x300_AND_IF__ETC___d141,
       r__h1656,
       r__h2001;

  // action method ma_core_req
  assign RDY_ma_core_req = ff_fwd_request_FULL_N ;
  assign CAN_FIRE_ma_core_req = ff_fwd_request_FULL_N ;
  assign WILL_FIRE_ma_core_req = EN_ma_core_req ;

  // value method mv_core_resp
  assign mv_core_resp = rg_resp_to_core ;
  assign RDY_mv_core_resp = 1'd1 ;

  // actionvalue method mav_fwd_req
  assign mav_fwd_req = ff_fwd_request_D_OUT ;
  assign RDY_mav_fwd_req = ff_fwd_request_EMPTY_N ;
  assign CAN_FIRE_mav_fwd_req = ff_fwd_request_EMPTY_N ;
  assign WILL_FIRE_mav_fwd_req = EN_mav_fwd_req ;

  // action method ma_csr_misa
  assign CAN_FIRE_ma_csr_misa = 1'd1 ;
  assign WILL_FIRE_ma_csr_misa = 1'd1 ;

  // action method ma_frm
  assign CAN_FIRE_ma_frm = 1'd1 ;
  assign WILL_FIRE_ma_frm = 1'd1 ;

  // action method ma_counter_interrupts
  assign RDY_ma_counter_interrupts = 1'd1 ;
  assign CAN_FIRE_ma_counter_interrupts = 1'd1 ;
  assign WILL_FIRE_ma_counter_interrupts = EN_ma_counter_interrupts ;

  // action method ma_clint_msip
  assign RDY_ma_clint_msip = 1'd1 ;
  assign CAN_FIRE_ma_clint_msip = 1'd1 ;
  assign WILL_FIRE_ma_clint_msip = EN_ma_clint_msip ;

  // action method ma_clint_mtip
  assign RDY_ma_clint_mtip = 1'd1 ;
  assign CAN_FIRE_ma_clint_mtip = 1'd1 ;
  assign WILL_FIRE_ma_clint_mtip = EN_ma_clint_mtip ;

  // action method ma_set_meip
  assign RDY_ma_set_meip = 1'd1 ;
  assign CAN_FIRE_ma_set_meip = 1'd1 ;
  assign WILL_FIRE_ma_set_meip = EN_ma_set_meip ;

  // value method mv_csr_mstatus
  assign mv_csr_mstatus =
	     { r__h1656,
	       13'd0,
	       rg_mprv,
	       2'd0,
	       rg_fs,
	       rg_mpp,
	       3'd0,
	       rg_mpie,
	       3'd0,
	       rg_mie,
	       3'd0 } ;
  assign RDY_mv_csr_mstatus = 1'd1 ;

  // value method mv_csrs_to_decode
  assign mv_csrs_to_decode =
	     { ma_upd_privilege_prv,
	       readdata__h1574[18:0],
	       readdata__h1564[18:0],
	       ma_csr_misa_m[25:0],
	       ma_frm_frm_val,
	       x_data__h1653 } ;
  assign RDY_mv_csrs_to_decode = 1'b1 ;

  // action method ma_upd_privilege
  assign CAN_FIRE_ma_upd_privilege = 1'd1 ;
  assign WILL_FIRE_ma_upd_privilege = 1'd1 ;

  // actionvalue method mav_upd_on_ret
  assign mav_upd_on_ret =
	     { ma_csr_misa_m[2] ? rg_mepc : result__h5993, 1'b0 } ;
  assign RDY_mav_upd_on_ret = 1'd1 ;
  assign CAN_FIRE_mav_upd_on_ret = 1'd1 ;
  assign WILL_FIRE_mav_upd_on_ret = EN_mav_upd_on_ret ;

  // actionvalue method mav_upd_on_trap
  assign mav_upd_on_trap =
	     { IF_rg_mode_5_EQ_1_87_AND_mav_upd_on_trap_c_BIT_ETC___d191,
	       2'b0 } ;
  assign RDY_mav_upd_on_trap = 1'd1 ;
  assign CAN_FIRE_mav_upd_on_trap = 1'd1 ;
  assign WILL_FIRE_mav_upd_on_trap = EN_mav_upd_on_trap ;

  // value method mv_mpp
  assign mv_mpp = rg_mpp ;

  // value method mv_resume_wfi
  assign mv_resume_wfi =
	     { _0_CONCAT_NOT_IF_wr_counter_interrupts_whas__9__ETC___d201,
	       2'd0 } !=
	     31'd0 ;
  assign RDY_mv_resume_wfi = 1'd1 ;

  // submodule ff_fwd_request
  // fifo : fifo to forward the core - request to the next group on a miss in the                      current group
  FIFO2 #(.width(32'd48), .guarded(1'd1)) ff_fwd_request(.RST(RST_N),
							 .CLK(CLK),
							 .D_IN(ff_fwd_request_D_IN),
							 .ENQ(ff_fwd_request_ENQ),
							 .DEQ(ff_fwd_request_DEQ),
							 .CLR(ff_fwd_request_CLR),
							 .D_OUT(ff_fwd_request_D_OUT),
							 .FULL_N(ff_fwd_request_FULL_N),
							 .EMPTY_N(ff_fwd_request_EMPTY_N));

  // rule RL_rg_resp_to_core__dreg_update
  assign CAN_FIRE_RL_rg_resp_to_core__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_rg_resp_to_core__dreg_update = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_rg_mcause_write_1__SEL_1 =
	     EN_ma_core_req && ma_core_req_req[47:36] == 12'h342 ;
  assign MUX_rg_mepc_write_1__SEL_1 =
	     EN_ma_core_req && ma_core_req_req[47:36] == 12'h341 ;
  assign MUX_rg_mie_write_1__SEL_1 =
	     EN_ma_core_req && ma_core_req_req[47:36] == 12'h300 ;
  assign MUX_rg_mpp_write_1__SEL_1 =
	     EN_ma_core_req &&
	     ma_core_req_req_BITS_47_TO_36_EQ_0x300_AND_IF__ETC___d141 ;
  assign MUX_rg_mtval_write_1__SEL_1 =
	     EN_ma_core_req && ma_core_req_req[47:36] == 12'h343 ;

  // inlined wires
  always@(ma_core_req_req or
	  x_data__h1653 or
	  readdata__h1564 or
	  x_data__h2059 or
	  x_data__h2080 or x_data__h2100 or rg_mtval or readdata__h1574)
  begin
    case (ma_core_req_req[47:36])
      12'h300: rg_resp_to_core_1_wget = { 1'd1, x_data__h1653 };
      12'h304: rg_resp_to_core_1_wget = { 1'd1, readdata__h1564 };
      12'h305: rg_resp_to_core_1_wget = { 1'd1, x_data__h2059 };
      12'h341: rg_resp_to_core_1_wget = { 1'd1, x_data__h2080 };
      12'h342: rg_resp_to_core_1_wget = { 1'd1, x_data__h2100 };
      12'h343: rg_resp_to_core_1_wget = { 1'd1, rg_mtval };
      12'h344: rg_resp_to_core_1_wget = { 1'd1, readdata__h1574 };
      default: rg_resp_to_core_1_wget = 33'd0;
    endcase
  end
  assign csr_op_arg_wget =
	     { ma_core_req_req[35:4],
	       IF_ma_core_req_req_BITS_47_TO_36_EQ_0x300_THEN_ETC___d109,
	       ma_core_req_req[3:2] } ;

  // register rg_fs
  assign rg_fs_D_IN = x_wget__h649[14:13] ;
  assign rg_fs_EN = MUX_rg_mie_write_1__SEL_1 ;

  // register rg_mcause
  assign rg_mcause_D_IN =
	     MUX_rg_mcause_write_1__SEL_1 ?
	       x_wget__h649[4:0] :
	       mav_upd_on_trap_c[4:0] ;
  assign rg_mcause_EN =
	     EN_ma_core_req && ma_core_req_req[47:36] == 12'h342 ||
	     EN_mav_upd_on_trap ;

  // register rg_mcounterie
  assign rg_mcounterie_D_IN = x__h3100[16] ;
  assign rg_mcounterie_EN =
	     EN_ma_core_req && ma_core_req_req[47:36] == 12'h304 ;

  // register rg_meie
  assign rg_meie_D_IN = x__h3100[11] ;
  assign rg_meie_EN = EN_ma_core_req && ma_core_req_req[47:36] == 12'h304 ;

  // register rg_meip
  assign rg_meip_D_IN = ma_set_meip_ex_i ;
  assign rg_meip_EN = EN_ma_set_meip ;

  // register rg_mepc
  assign rg_mepc_D_IN =
	     MUX_rg_mepc_write_1__SEL_1 ?
	       x_wget__h649[31:1] :
	       mav_upd_on_trap_pc[31:1] ;
  assign rg_mepc_EN =
	     EN_ma_core_req && ma_core_req_req[47:36] == 12'h341 ||
	     EN_mav_upd_on_trap ;

  // register rg_mie
  always@(MUX_rg_mie_write_1__SEL_1 or
	  x_wget__h649 or EN_mav_upd_on_ret or rg_mpie or EN_mav_upd_on_trap)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_rg_mie_write_1__SEL_1: rg_mie_D_IN = x_wget__h649[3];
      EN_mav_upd_on_ret: rg_mie_D_IN = rg_mpie;
      EN_mav_upd_on_trap: rg_mie_D_IN = 1'd0;
      default: rg_mie_D_IN = 1'bx /* unspecified value */ ;
    endcase
  end
  assign rg_mie_EN =
	     EN_ma_core_req && ma_core_req_req[47:36] == 12'h300 ||
	     EN_mav_upd_on_ret ||
	     EN_mav_upd_on_trap ;

  // register rg_minterrupt
  assign rg_minterrupt_D_IN =
	     MUX_rg_mcause_write_1__SEL_1 ?
	       x_wget__h649[31] :
	       mav_upd_on_trap_c[5] ;
  assign rg_minterrupt_EN =
	     EN_ma_core_req && ma_core_req_req[47:36] == 12'h342 ||
	     EN_mav_upd_on_trap ;

  // register rg_mode
  assign rg_mode_D_IN = x_wget__h649[1:0] ;
  assign rg_mode_EN =
	     EN_ma_core_req && ma_core_req_req[47:36] == 12'h305 &&
	     x_wget__h649[1:0] < 2'd2 ;

  // register rg_mpie
  always@(MUX_rg_mie_write_1__SEL_1 or
	  x_wget__h649 or EN_mav_upd_on_trap or rg_mie or EN_mav_upd_on_ret)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_rg_mie_write_1__SEL_1: rg_mpie_D_IN = x_wget__h649[7];
      EN_mav_upd_on_trap: rg_mpie_D_IN = rg_mie;
      EN_mav_upd_on_ret: rg_mpie_D_IN = 1'd1;
      default: rg_mpie_D_IN = 1'bx /* unspecified value */ ;
    endcase
  end
  assign rg_mpie_EN =
	     EN_ma_core_req && ma_core_req_req[47:36] == 12'h300 ||
	     EN_mav_upd_on_trap ||
	     EN_mav_upd_on_ret ;

  // register rg_mpp
  always@(MUX_rg_mpp_write_1__SEL_1 or
	  x_wget__h649 or
	  EN_mav_upd_on_trap or ma_upd_privilege_prv or EN_mav_upd_on_ret)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_rg_mpp_write_1__SEL_1: rg_mpp_D_IN = x_wget__h649[12:11];
      EN_mav_upd_on_trap: rg_mpp_D_IN = ma_upd_privilege_prv;
      EN_mav_upd_on_ret: rg_mpp_D_IN = 2'd0;
      default: rg_mpp_D_IN = 2'bxx /* unspecified value */ ;
    endcase
  end
  assign rg_mpp_EN =
	     EN_ma_core_req &&
	     ma_core_req_req_BITS_47_TO_36_EQ_0x300_AND_IF__ETC___d141 ||
	     EN_mav_upd_on_trap ||
	     EN_mav_upd_on_ret ;

  // register rg_mprv
  assign rg_mprv_D_IN = x_wget__h649[17] ;
  assign rg_mprv_EN = MUX_rg_mie_write_1__SEL_1 ;

  // register rg_msie
  assign rg_msie_D_IN = x__h3100[3] ;
  assign rg_msie_EN = EN_ma_core_req && ma_core_req_req[47:36] == 12'h304 ;

  // register rg_msip
  assign rg_msip_D_IN = ma_clint_msip_intrpt ;
  assign rg_msip_EN = EN_ma_clint_msip ;

  // register rg_mtie
  assign rg_mtie_D_IN = x__h3100[7] ;
  assign rg_mtie_EN = EN_ma_core_req && ma_core_req_req[47:36] == 12'h304 ;

  // register rg_mtip
  assign rg_mtip_D_IN = ma_clint_mtip_intrpt ;
  assign rg_mtip_EN = EN_ma_clint_mtip ;

  // register rg_mtval
  assign rg_mtval_D_IN =
	     MUX_rg_mtval_write_1__SEL_1 ?
	       x_wget__h649 :
	       mav_upd_on_trap_tval ;
  assign rg_mtval_EN =
	     EN_ma_core_req && ma_core_req_req[47:36] == 12'h343 ||
	     EN_mav_upd_on_trap ;

  // register rg_mtvec
  assign rg_mtvec_D_IN = x_wget__h649[31:2] ;
  assign rg_mtvec_EN = EN_ma_core_req && ma_core_req_req[47:36] == 12'h305 ;

  // register rg_resp_to_core
  assign rg_resp_to_core_D_IN =
	     EN_ma_core_req ? rg_resp_to_core_1_wget : 33'd0 ;
  assign rg_resp_to_core_EN = 1'd1 ;

  // submodule ff_fwd_request
  assign ff_fwd_request_D_IN = ma_core_req_req ;
  assign ff_fwd_request_ENQ =
	     EN_ma_core_req && ma_core_req_req[47:36] != 12'h300 &&
	     ma_core_req_req[47:36] != 12'h304 &&
	     ma_core_req_req[47:36] != 12'h344 &&
	     ma_core_req_req[47:36] != 12'h305 &&
	     ma_core_req_req[47:36] != 12'h341 &&
	     ma_core_req_req[47:36] != 12'h342 &&
	     ma_core_req_req[47:36] != 12'h343 ;
  assign ff_fwd_request_DEQ = EN_mav_fwd_req ;
  assign ff_fwd_request_CLR = 1'b0 ;

  // remaining internal signals
  module_fn_csr_op instance_fn_csr_op_0(.fn_csr_op_writedata(x_wget_fst__h2296),
					.fn_csr_op_readdata(x_wget_snd_fst__h2381),
					.fn_csr_op_op(x_wget_snd_snd__h2382),
					.fn_csr_op(x__h5393));
  assign IF_rg_mode_5_EQ_1_87_AND_mav_upd_on_trap_c_BIT_ETC___d191 =
	     (rg_mode == 2'd1 && mav_upd_on_trap_c[5]) ?
	       rg_mtvec + { 25'd0, mav_upd_on_trap_c[4:0] } :
	       rg_mtvec ;
  assign _0_CONCAT_NOT_IF_wr_counter_interrupts_whas__9__ETC___d201 =
	     { 15'd0,
	       r__h2001 & rg_mcounterie,
	       4'd0,
	       rg_meip & rg_meie,
	       3'd0,
	       rg_mtip & rg_mtie,
	       3'd0,
	       rg_msip & rg_msie } ;
  assign lv_mi_mask__h1454 =
	     { 22'd4194303,
	       ma_csr_misa_m[18],
	       ma_csr_misa_m[13],
	       2'b11,
	       ma_csr_misa_m[18],
	       ma_csr_misa_m[13],
	       2'b11,
	       ma_csr_misa_m[18],
	       ma_csr_misa_m[13] } ;
  assign ma_core_req_req_BITS_47_TO_36_EQ_0x300_AND_IF__ETC___d141 =
	     ma_core_req_req[47:36] == 12'h300 &&
	     (x_wget__h649[12:11] == 2'd3 ||
	      ma_csr_misa_m[18] && x_wget__h649[12:11] == 2'd1 ||
	      ma_csr_misa_m[20] && x_wget__h649[12:11] == 2'd0) ;
  assign r1__read__h1762 = { r1__read__h1764, 1'd0 } ;
  assign r1__read__h1764 = { r1__read__h1766, 1'b0 } ;
  assign r1__read__h1766 = { r1__read__h1768, rg_msie } ;
  assign r1__read__h1768 = { r1__read__h1770, 1'd0 } ;
  assign r1__read__h1770 = { r1__read__h1772, 1'd0 } ;
  assign r1__read__h1772 = { r1__read__h1774, 1'b0 } ;
  assign r1__read__h1774 = { r1__read__h1776, rg_mtie } ;
  assign r1__read__h1776 = { r1__read__h1778, 1'd0 } ;
  assign r1__read__h1778 = { r1__read__h1780, 1'd0 } ;
  assign r1__read__h1780 = { r1__read__h1782, 1'b0 } ;
  assign r1__read__h1782 = { r1__read__h1784, rg_meie } ;
  assign r1__read__h1784 = { r1__read__h1786, 4'd0 } ;
  assign r1__read__h1786 = { 15'd3, rg_mcounterie } ;
  assign r1__read__h1965 = { r1__read__h1967, 1'd0 } ;
  assign r1__read__h1967 = { r1__read__h1969, 1'b0 } ;
  assign r1__read__h1969 = { r1__read__h1971, rg_msip } ;
  assign r1__read__h1971 = { r1__read__h1973, 1'd0 } ;
  assign r1__read__h1973 = { r1__read__h1975, 1'd0 } ;
  assign r1__read__h1975 = { r1__read__h1977, 1'd0 } ;
  assign r1__read__h1977 = { r1__read__h1979, rg_mtip } ;
  assign r1__read__h1979 = { r1__read__h1981, 1'd0 } ;
  assign r1__read__h1981 = { r1__read__h1983, 1'd0 } ;
  assign r1__read__h1983 = { r1__read__h1985, 1'b0 } ;
  assign r1__read__h1985 = { r1__read__h1987, rg_meip } ;
  assign r1__read__h1987 = { r1__read__h1989, 4'd0 } ;
  assign r1__read__h1989 = { 15'd0, r__h2001 } ;
  assign r__h1656 = rg_fs == 2'b11 ;
  assign r__h2001 = x__h2004 != 29'd0 ;
  assign readdata__h1564 = rg_csr_mie__read__h1760 & lv_mi_mask__h1454 ;
  assign readdata__h1574 = rg_csr_mip__read__h1963 & lv_mi_mask__h1454 ;
  assign result__h5993 = { rg_mepc[30:1], 1'd0 } ;
  assign rg_csr_mie__read__h1760 = { r1__read__h1762, 1'd0 } ;
  assign rg_csr_mip__read__h1963 = { r1__read__h1965, 1'd0 } ;
  assign x__h2004 =
	     EN_ma_counter_interrupts ? ma_counter_interrupts_i : 29'd0 ;
  assign x__h3100 = x_wget__h649 & lv_mi_mask__h1454 ;
  assign x_data__h1653 = mv_csr_mstatus ;
  assign x_data__h2059 = { rg_mtvec, rg_mode } ;
  assign x_data__h2080 = { rg_mepc, 1'b0 } ;
  assign x_data__h2100 = { rg_minterrupt, 26'd0, rg_mcause } ;
  assign x_wget_fst__h2296 = csr_op_arg_wget[65:34] ;
  assign x_wget_snd_fst__h2381 = csr_op_arg_wget[33:2] ;
  assign x_wget_snd_snd__h2382 = csr_op_arg_wget[1:0] ;
  always@(ma_core_req_req or
	  rg_mtval or
	  x_data__h1653 or
	  readdata__h1564 or
	  x_data__h2059 or x_data__h2080 or x_data__h2100 or readdata__h1574)
  begin
    case (ma_core_req_req[47:36])
      12'h300:
	  IF_ma_core_req_req_BITS_47_TO_36_EQ_0x300_THEN_ETC___d109 =
	      x_data__h1653;
      12'h304:
	  IF_ma_core_req_req_BITS_47_TO_36_EQ_0x300_THEN_ETC___d109 =
	      readdata__h1564;
      12'h305:
	  IF_ma_core_req_req_BITS_47_TO_36_EQ_0x300_THEN_ETC___d109 =
	      x_data__h2059;
      12'h341:
	  IF_ma_core_req_req_BITS_47_TO_36_EQ_0x300_THEN_ETC___d109 =
	      x_data__h2080;
      12'h342:
	  IF_ma_core_req_req_BITS_47_TO_36_EQ_0x300_THEN_ETC___d109 =
	      x_data__h2100;
      12'h344:
	  IF_ma_core_req_req_BITS_47_TO_36_EQ_0x300_THEN_ETC___d109 =
	      readdata__h1574;
      default: IF_ma_core_req_req_BITS_47_TO_36_EQ_0x300_THEN_ETC___d109 =
		   rg_mtval;
    endcase
  end
  always@(ma_core_req_req or x__h5393)
  begin
    case (ma_core_req_req[47:36])
      12'h300, 12'h304, 12'h305, 12'h341, 12'h344: x_wget__h649 = x__h5393;
      default: x_wget__h649 = x__h5393;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_fs <= `BSV_ASSIGNMENT_DELAY 2'd0;
	rg_mcause <= `BSV_ASSIGNMENT_DELAY 5'd0;
	rg_mcounterie <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_meie <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_meip <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_mepc <= `BSV_ASSIGNMENT_DELAY 31'd0;
	rg_mie <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_minterrupt <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_mode <= `BSV_ASSIGNMENT_DELAY 2'd0;
	rg_mpie <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_mpp <= `BSV_ASSIGNMENT_DELAY 2'b0;
	rg_mprv <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_msie <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_msip <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_mtie <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_mtip <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_mtval <= `BSV_ASSIGNMENT_DELAY 32'd0;
	rg_mtvec <= `BSV_ASSIGNMENT_DELAY 30'd0;
	rg_resp_to_core <= `BSV_ASSIGNMENT_DELAY 33'd0;
      end
    else
      begin
        if (rg_fs_EN) rg_fs <= `BSV_ASSIGNMENT_DELAY rg_fs_D_IN;
	if (rg_mcause_EN) rg_mcause <= `BSV_ASSIGNMENT_DELAY rg_mcause_D_IN;
	if (rg_mcounterie_EN)
	  rg_mcounterie <= `BSV_ASSIGNMENT_DELAY rg_mcounterie_D_IN;
	if (rg_meie_EN) rg_meie <= `BSV_ASSIGNMENT_DELAY rg_meie_D_IN;
	if (rg_meip_EN) rg_meip <= `BSV_ASSIGNMENT_DELAY rg_meip_D_IN;
	if (rg_mepc_EN) rg_mepc <= `BSV_ASSIGNMENT_DELAY rg_mepc_D_IN;
	if (rg_mie_EN) rg_mie <= `BSV_ASSIGNMENT_DELAY rg_mie_D_IN;
	if (rg_minterrupt_EN)
	  rg_minterrupt <= `BSV_ASSIGNMENT_DELAY rg_minterrupt_D_IN;
	if (rg_mode_EN) rg_mode <= `BSV_ASSIGNMENT_DELAY rg_mode_D_IN;
	if (rg_mpie_EN) rg_mpie <= `BSV_ASSIGNMENT_DELAY rg_mpie_D_IN;
	if (rg_mpp_EN) rg_mpp <= `BSV_ASSIGNMENT_DELAY rg_mpp_D_IN;
	if (rg_mprv_EN) rg_mprv <= `BSV_ASSIGNMENT_DELAY rg_mprv_D_IN;
	if (rg_msie_EN) rg_msie <= `BSV_ASSIGNMENT_DELAY rg_msie_D_IN;
	if (rg_msip_EN) rg_msip <= `BSV_ASSIGNMENT_DELAY rg_msip_D_IN;
	if (rg_mtie_EN) rg_mtie <= `BSV_ASSIGNMENT_DELAY rg_mtie_D_IN;
	if (rg_mtip_EN) rg_mtip <= `BSV_ASSIGNMENT_DELAY rg_mtip_D_IN;
	if (rg_mtval_EN) rg_mtval <= `BSV_ASSIGNMENT_DELAY rg_mtval_D_IN;
	if (rg_mtvec_EN) rg_mtvec <= `BSV_ASSIGNMENT_DELAY rg_mtvec_D_IN;
	if (rg_resp_to_core_EN)
	  rg_resp_to_core <= `BSV_ASSIGNMENT_DELAY rg_resp_to_core_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_fs = 2'h2;
    rg_mcause = 5'h0A;
    rg_mcounterie = 1'h0;
    rg_meie = 1'h0;
    rg_meip = 1'h0;
    rg_mepc = 31'h2AAAAAAA;
    rg_mie = 1'h0;
    rg_minterrupt = 1'h0;
    rg_mode = 2'h2;
    rg_mpie = 1'h0;
    rg_mpp = 2'h2;
    rg_mprv = 1'h0;
    rg_msie = 1'h0;
    rg_msip = 1'h0;
    rg_mtie = 1'h0;
    rg_mtip = 1'h0;
    rg_mtval = 32'hAAAAAAAA;
    rg_mtvec = 30'h2AAAAAAA;
    rg_resp_to_core = 33'h0AAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mk_csr_grp1

