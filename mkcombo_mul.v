//
// Generated by Bluespec Compiler, version 2021.07-3-g8227dc97 (build 8227dc97)
//
// On Fri Sep  3 12:08:15 PDT 2021
//
//
// Ports:
// Name                         I/O  size props
// mv_output                      O    38
// RDY_mv_output                  O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// ma_inputs_in1                  I    32
// ma_inputs_in2                  I    32
// ma_inputs_funct3               I     3
// EN_ma_inputs                   I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkcombo_mul(CLK,
		   RST_N,

		   ma_inputs_in1,
		   ma_inputs_in2,
		   ma_inputs_funct3,
		   EN_ma_inputs,

		   mv_output,
		   RDY_mv_output);
  input  CLK;
  input  RST_N;

  // action method ma_inputs
  input  [31 : 0] ma_inputs_in1;
  input  [31 : 0] ma_inputs_in2;
  input  [2 : 0] ma_inputs_funct3;
  input  EN_ma_inputs;

  // value method mv_output
  output [37 : 0] mv_output;
  output RDY_mv_output;

  // signals for module outputs
  wire [37 : 0] mv_output;
  wire RDY_mv_output;

  // register rg_fn3
  reg [2 : 0] rg_fn3;
  wire [2 : 0] rg_fn3_D_IN;
  wire rg_fn3_EN;

  // register rg_op1_0
  reg [32 : 0] rg_op1_0;
  wire [32 : 0] rg_op1_0_D_IN;
  wire rg_op1_0_EN;

  // register rg_op2_0
  reg [32 : 0] rg_op2_0;
  wire [32 : 0] rg_op2_0_D_IN;
  wire rg_op2_0_EN;

  // register rg_valid_0
  reg rg_valid_0;
  wire rg_valid_0_D_IN, rg_valid_0_EN;

  // ports of submodule signed_mul
  wire [65 : 0] signed_mul_c;
  wire [32 : 0] signed_mul_a, signed_mul_b;

  // rule scheduling signals
  wire CAN_FIRE_RL_rg_valid_0__dreg_update,
       CAN_FIRE_RL_rl_perform_mul,
       CAN_FIRE_ma_inputs,
       WILL_FIRE_RL_rg_valid_0__dreg_update,
       WILL_FIRE_RL_rl_perform_mul,
       WILL_FIRE_ma_inputs;

  // remaining internal signals
  wire [31 : 0] x_wget__h626;
  wire sign1__h952, sign2__h953;

  // action method ma_inputs
  assign CAN_FIRE_ma_inputs = 1'd1 ;
  assign WILL_FIRE_ma_inputs = EN_ma_inputs ;

  // value method mv_output
  assign mv_output = { x_wget__h626, rg_valid_0, 5'd0 } ;
  assign RDY_mv_output = 1'd1 ;

  // submodule signed_mul
  signedmul #(.AWIDTH(32'd33), .BWIDTH(32'd33)) signed_mul(.a(signed_mul_a),
							   .b(signed_mul_b),
							   .c(signed_mul_c));

  // rule RL_rl_perform_mul
  assign CAN_FIRE_RL_rl_perform_mul = 1'd1 ;
  assign WILL_FIRE_RL_rl_perform_mul = 1'd1 ;

  // rule RL_rg_valid_0__dreg_update
  assign CAN_FIRE_RL_rg_valid_0__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_rg_valid_0__dreg_update = 1'd1 ;

  // register rg_fn3
  assign rg_fn3_D_IN = ma_inputs_funct3 ;
  assign rg_fn3_EN = EN_ma_inputs ;

  // register rg_op1_0
  assign rg_op1_0_D_IN = { sign1__h952 & ma_inputs_in1[31], ma_inputs_in1 } ;
  assign rg_op1_0_EN = EN_ma_inputs ;

  // register rg_op2_0
  assign rg_op2_0_D_IN = { sign2__h953 & ma_inputs_in2[31], ma_inputs_in2 } ;
  assign rg_op2_0_EN = EN_ma_inputs ;

  // register rg_valid_0
  assign rg_valid_0_D_IN = EN_ma_inputs ;
  assign rg_valid_0_EN = 1'd1 ;

  // submodule signed_mul
  assign signed_mul_a = rg_op1_0 ;
  assign signed_mul_b = rg_op2_0 ;

  // remaining internal signals
  assign sign1__h952 = ma_inputs_funct3[1] ^ ma_inputs_funct3[0] ;
  assign sign2__h953 = ma_inputs_funct3[1:0] == 2'd1 ;
  assign x_wget__h626 =
	     (rg_fn3[1:0] == 2'd0) ?
	       signed_mul_c[31:0] :
	       signed_mul_c[63:32] ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_fn3 <= `BSV_ASSIGNMENT_DELAY 3'd0;
	rg_op1_0 <= `BSV_ASSIGNMENT_DELAY 33'd0;
	rg_op2_0 <= `BSV_ASSIGNMENT_DELAY 33'd0;
	rg_valid_0 <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (rg_fn3_EN) rg_fn3 <= `BSV_ASSIGNMENT_DELAY rg_fn3_D_IN;
	if (rg_op1_0_EN) rg_op1_0 <= `BSV_ASSIGNMENT_DELAY rg_op1_0_D_IN;
	if (rg_op2_0_EN) rg_op2_0 <= `BSV_ASSIGNMENT_DELAY rg_op2_0_D_IN;
	if (rg_valid_0_EN)
	  rg_valid_0 <= `BSV_ASSIGNMENT_DELAY rg_valid_0_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_fn3 = 3'h2;
    rg_op1_0 = 33'h0AAAAAAAA;
    rg_op2_0 = 33'h0AAAAAAAA;
    rg_valid_0 = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkcombo_mul

